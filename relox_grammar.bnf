(* 
    Syntactic Grammer Definition
    
    Notation is homebrew BNF (see bnf.sublime-syntax for highlighting).
    
    I plan to implement a recursive descent parser, so care needs to be taken to avoid any left recursion in the grammar.
*)



(*** Expressions ***)


(* Original left-recursive version
primary ::= LITERAL | lvalue | call | "(" expression ")" ;
lvalue ::= IDENTIFIER | subscript | access ;  (* so called because they can appear on the left side of assignment, see below *)
subscript ::= primary "[" expression "]" ;
access ::= primary "." IDENTIFIER ; 
*)

(* New non-left-recursive version *)
atom ::= LITERAL | IDENTIFIER | "(" expression ")" ;
primary ::= atom ( access | subscript | invocation | object-constructor )* ; (* object-constructor is here so you can do stuff like invoke a temporary object: { option: value }(args) *)
subscript ::= "[" expression "]" ;
access ::= "." IDENTIFIER ;

lvalue ::= IDENTIFIER | primary subscript | primary access ;  (* so called because they can appear on the left side of assignment, see Access below *)

                                        (* Notes for parser implemention: *)
expression ::= primary                  (* technically made redundant by binop-expression, included here for clarity *)
             | binop-expression         (* starts with a primary *)
             | assignment-expression    (* starts with a primary or "var" *)  (* at this level and above, we need to grab the next primary *)
             | unary-expression         (* starts with an unary operator *)
             | object-constructor       (* starts with a "{" symbol. anonymous object *)
             | if-expression            (* starts with "if" keyword *)
             | function-def             (* starts with "fun" keyword *)
             | class-def                (* starts with "class" keyword *)
             | tuple-constructor ;      (* indicated by comma after expression *)


(*** Binary and Unary Operators ***)

(*
    Operator precendence in order from strong to weak binding
    (left associative unless otherwise specified)
     
     1:  (unary -) (unary +) not          (right associative)
     2:  * / %
     3:  + - 
     4:  << >>
     5:  & 
     6:  ^ 
     7:  | 
     8:  < > <= >= == !=        (not associative, require grouping)
     9:  and 
    10:  or

*)

(* these special cases escape the general operator production below *)
binary[1] ::= primary ; (* terminates the binop precedence stack *)
binary[8] ::= comparison ;

(* OPERATOR[N] refers to the symbols in different levels of the operator precedence table above *)
binary[N] ::= binary[N-1] ( OPERATOR[N] binary[N-1] )* ;

comparison ::= binary[7] ( OPERATOR[8] binary[7] )? ; (* not associative *)

(* top-level operator expression *)
binop-expression ::= binary[10] ;

(* right associative *)
unary-expression ::= ( "-" | "+" | "not" ) unary | primary ;


(*** Assignment ***)

(* 
    The "var" keyword creates the variable in current scope, otherwise the global scope is searched for an 
    existing variable if cannot be not found locally. If it still can't be found, then the assignment is an error.
    
    Assignment statements support sequence destructuring, assignment expressions do not.
*)

(* right associative *)
assignment-expression ::= assignment-target ( "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ) expression ;
assignment-target ::= ( "var" )? lvalue ; 

assignment-statement ::= assignment-target-list  "=" expression-list ;
assignment-target-list ::= assignment-target ( "," assignment-target )* ;

expression-list ::= expression ( "," expression )* ;


(*** Function/Method Calls ***)

invocation ::= "(" ... ")" ;  (* WIP *)

(*** Constructors ***)

object-constructor ::= "{" member-initializer ( "," member-initializer )* "}" ;
member-initializer ::= ( IDENTIFIER | "[" primary "]" ) ":" expression ;  (* initializers can assign to members or index *)


(* syntax for tuple-constructor has special casing for single-element tuples and the empty tuple *)
tuple-constructor ::= expression-list | "(" expression "," ")" | "(" ")" ;
