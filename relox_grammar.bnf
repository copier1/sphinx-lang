(* 
    Syntactic Grammer Definition
    
    Notation is homebrew BNF (see bnf.sublime-syntax for highlighting).
    
    I plan to implement a recursive descent parser, so care needs to be taken to avoid any left recursion in the grammar.
*)



(*** Expressions ***)

(*** Access and Indexing ***)

primary ::= LITERAL | lvalue | call | "(" expression ")" ;

lvalue ::= IDENTIFIER | subscript | access ;  (* so called because they can appear on the left side of assignment, see below *)
subscript ::= primary "[" expression "]" ;
access ::= primary "." IDENTIFIER ;

expression ::= primary
             | op-expression
             | if-expression
             | assignment-expression 
             | tuple-constructor
             | object-constructor
             | function-def
             | class-def ;


(*** Binary and Unary Operators ***)

(*
    Operator precendence in order from strong to weak binding
    (left associative unless otherwise specified)
     
     1:  (unary -) not          (right associative)
     2:  * / %
     3:  + - 
     4:  << >>
     5:  & 
     6:  ^ 
     7:  | 
     8:  < > <= >= == !=        (not associative, require grouping)
     9:  and 
    10:  or

*)

(* these special cases escape the general operator production below *)
operand[1] ::= unary ;
operand[8] ::= comparison ;

(* OPERATOR[N] refers to the symbols in different levels of the operator precedence table above *)
operand[N] ::= operand[N-1] ( OPERATOR[N] operand[N-1] )* ;

(* right associative, and terminates the operand[N] stack using primary *)
unary ::= ( "-" | "not" ) unary | primary ;

comparison ::= operand[7] OPERATOR[8] operand[7] ; (* not associative *)

(* top-level operator expression *)
op-expression ::= operand[10];


(*** Assignment ***)

(* 
    The "var" keyword creates the variable in current scope, otherwise the global scope is searched for an 
    existing variable if cannot be not found locally. If it still can't be found, then the assignment is an error.
    
    Assignment statements support sequence destructuring, assignment expressions do not.
*)

(* right associative *)
assignment-expression ::= assignment-target ( "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ) assignment | expression ;
assignment-target ::= ( "var" )? lvalue ; 

assignment-statement ::= assignment-target-list  "=" expression-list ;
assignment-target-list ::= assignment-target ( "," assignment-target )* ;

expression-list ::= expression ( "," expression )* ;


(*** Function/Method Calls ***)



(*** Constructors ***)

tuple-constructor ::= expression-list | "(" expression "," ")" | "(" ")" ;

object-constructor ::= ( primary )? "{" member-initializer ( "," member-initializer )* "}" ;
member-initializer ::= ( IDENTIFIER | "[" primary "]" ) ":" expression ;  (* initializers can assign to members or index *)
