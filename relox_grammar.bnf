(* 
    Syntactic Grammer Definition
    
    Notation is homebrew BNF (see bnf.sublime-syntax for highlighting).
    
    I plan to implement a recursive descent parser, so care needs to be taken to avoid any left recursion in the grammar.
*)



(*** Expressions ***)


(* New non-left-recursive version *)
atom ::= LITERAL | IDENTIFIER | "(" expression ")" ;
primary ::= atom ( access-item )* ; 

access-item ::= member-access | index-access | invocation | object-constructor ;
index-access ::= "[" expression "]" ;
member-access ::= "." IDENTIFIER ;

lvalue ::= IDENTIFIER | primary index-access | primary member-access ;  (* so called because they can appear on the left side of assignment, see Access below *)


(* This is more for specification than implementation, as it is left-recursive. 
   See the end of this file for a non-left-recursive reformulation.
*)
expression ::= primary
             | class-def
             | function-def
             | if-expression
             | UNARY_OP expression
             | expression BINARY_OP expression
             | assignment-expression
             | object-constructor
             | tuple-constructor ;

(*** Binary and Unary Operators ***)

(*
    Operator precendence in order from strong to weak binding
    (left associative unless otherwise specified)
     
     1:  (unary -) (unary +) not          (right associative)
     2:  * / %
     3:  + - 
     4:  << >>
     5:  & 
     6:  ^ 
     7:  | 
     8:  < > <= >= == !=        (not associative, require grouping)
     9:  and 
    10:  or

*)


(*** Assignment ***)

(* 
    The "var" keyword creates the variable in current scope, otherwise the global scope is searched for an 
    existing variable if cannot be not found locally. If it still can't be found, then the assignment is an error.
    
    Assignment statements support sequence destructuring, assignment expressions do not.
*)

(* right associative *)
assignment-expression ::= assignment-target ( "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ) expression ;
assignment-target ::= ( "var" )? lvalue ; 

assignment-statement ::= assignment-target-list  "=" expression-list ;
assignment-target-list ::= assignment-target ( "," assignment-target )* ;

expression-list ::= expression ( "," expression )* ;


(*** Function/Method Calls ***)

invocation ::= "(" ... ")" ;  (* WIP *)

(*** Constructors ***)

object-constructor ::= "{" member-initializer ( "," member-initializer )* "}" ;
member-initializer ::= ( IDENTIFIER | "[" primary "]" ) ":" expression ;  (* initializers can assign to members or index *)


(* syntax for tuple-constructor has special casing for single-element tuples and the empty tuple *)
tuple-constructor ::= expression-list | "(" expression "," ")" | "(" ")" ;



(* Non left-recursive version of `expression` for implementation *)

primary-expression ::= immediate-expression | primary | "(" expression "," ")" | "(" ")" ;

(* These expressions can all be identified by their first symbol *)
immediate-expression ::= class-def
                       | function-def
                       | if-expression
                       | object-constructor ;

unary-expression ::= UNARY_OP unary | primary-expression ;

operand[1] ::= unary-expression ;
operand[8] ::= comparison ;
operand[N] ::= operand[N-1] ( OPERATOR[N] operand[N-1] )* ;

assignment ::= assignment-expression | operand[10] ;

expression ::= assignment ( "," assignment )*;  (* possible tuples *)