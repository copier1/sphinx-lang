(* 
    Syntactic Grammer Definition
    
    Notation is homebrew BNF (see bnf.sublime-syntax for highlighting).
    
    I plan to implement a recursive descent parser, so care needs to be taken to avoid any left recursion in the grammar.
*)


(*** Statements ***)

statement ::= ";"
            | assignment-statement
            | while-loop
            | do-while-loop
            | for-loop 
            | expression ;

statement-block ::= ( statement | control-flow )* ;
control-flow ::= "continue" ( label )? | "break" ( label )? | "return" expression ;

while-loop ::=  ( label )? "while" expression "do" statement-block "end" ;
do-while-loop ::= ( label )? "do" statement-block "while" expression "end" ;

for-loop ::= ( label ":" )? "for" ... "end" ; (* TODO *)

label ::= "::" LABELNAME ;

(*** Expressions ***)

atom ::= LITERAL | identifier | "self" | "super" | "(" expression ")" ;
identifier ::= IDENTIFIER | "global" IDENTIFIER | "upval" IDENTIFIER ;
primary ::= atom ( access-item )* ; 

access-item ::= member-access | index-access | invocation | object-constructor ;
index-access ::= "[" expression "]" ;
member-access ::= "." IDENTIFIER ;

lvalue ::= identifier | primary index-access | primary member-access ;  (* so called because they can appear on the left side of assignment, see Access below *)


(* 
    This expression production is left-recursive, and as such, the actual recursive descent parser implementation differs somewhat (see the bottom of this file)
*)
expression ::= primary
             | class-def
             | function-def
             | if-expression
             | block-expression
             | UNARY_OP expression
             | expression BINARY_OP expression
             | assignment-expression
             | object-constructor
             | tuple-constructor ;

(*** if/block Expressions ***)

if-expression ::= "if" expression "then" block ( "elseif" block )* ( "else" block )? "end" ;
block-expression ::= ( label )? "begin" ( statement | control-flow | "break" ( label )? expression )* "end" ;  (* break can be supplied a value inside of begin-blocks *)

(*** Assignment ***)

(* 
    The "var" keyword creates the variable in current scope, otherwise the global scope is searched for an 
    existing variable if cannot be not found locally. If it still can't be found, then the assignment is an error.
    
    Assignment statements support sequence destructuring, assignment expressions do not.
*)

(* right associative *)
assignment-expression ::= lvalue ( "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" ) expression ;

assignment-statement ::= "var" lvalue-list  "=" expression-list ;
lvalue-list ::= lvalue ( "," lvalue )* ;

expression-list ::= expression ( "," expression )* ;

(*** Function/Method Calls ***)

(* 
Special case here: An invocation cannot be the first production following a new line. 
This is the only situation where white space is considered when parsing RLO.
This prevents function calls from splitting across lines (an issue that Lua also has, and our syntax is based on Lua).
However RLO has tuples, so its important for us to deal with that.
*)
invocation ::= "(" ")" | "(" argument ( "," argument )* ")" ; 
argument ::= ( "..." )? expression ;  (* support argument unpacking syntax *)

(*** Constructors ***)

object-constructor ::= "{" member-initializer ( "," member-initializer )* "}" ;
member-initializer ::= ( IDENTIFIER | "[" primary "]" ) ":" expression ;  (* initializers can assign to members or index *)


(* syntax for tuple-constructor has special casing for single-element tuples and the empty tuple *)
tuple-constructor ::= expression-list | "(" expression "," ")" | "(" ")" ;

(*** Function Defs ***)

function-def ::= ... ; (* TODO *)

(*** Class Defs ***)

class-def ::= ... ; (* TODO *)


(***** Non left-recursive version of `expression` for implementation *****)

tuple-constructor ::= "(" expression ( "," expression )+ ")" | "(" ")" ;

primary-expression ::= immediate-expression | primary | tuple-constructor | "(" expression ")" ;

(* These expressions can all be identified by their first symbol *)
immediate-expression ::= class-def
                       | function-def
                       | if-expression
                       | object-constructor ;

unary-expression ::= UNARY_OP unary-expression | primary-expression ;

(*
    Operator precendence in order from strong to weak binding
    (left associative unless otherwise specified)
     
     1:  (unary -) (unary +) not          (right associative)
     2:  * / %
     3:  + - 
     4:  << >>
     5:  & 
     6:  ^ 
     7:  | 
     8:  < > <= >= == !=
     9:  and 
    10:  or

*)

operand[1] ::= unary-expression ;
operand[N] ::= operand[N-1] ( OPERATOR[N] operand[N-1] )* ;

assignment ::= assignment-expression | operand[10] ;

(* top-level tuples don't require parens - however, single element tuples are not allowed here, use tuple-constructor instead *)
expression ::= assignment ( "," assignment )*;