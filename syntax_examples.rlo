#{
    Block Comment
   #{   Nesting!   }#
}#

# Your first ReLox program!
echo "Hello, world!"  # print() function will be available later once there is a builtin library

# Semicolons are optional.
"One Stmt"; "Two Stmt"

# Like Lua, the syntax has been chosen to ensure that 
# the end of a statement can always be inferred without
# needing to be whitespace-sensitive.


# Booleans
true  # Not false.
false # Not *not* false.

# Numbers
1234   # An integer.
12.34  # A decimal number.
0xFACE # Hexadecimal integer.

# Strings
"I am a string"
""     # The empty string.
"123"  # self is a string, not a number.
'And then she said, "woah."'  # Can be single or double quoted.
"\ttab\nnewline, literal\\backslash" # Escape sequences
r"/[\w._%+-]+@[\w.-]+\.[a-zA-Z]{2,4}/"  # Literal with escape sequences disabled

# Nil
nil

# Tuple
"abc", 123

# parens are only required for these special cases
()  # the empty tuple
("solo",)  # tuple with one element

# Object
Person { name: "Bob", age: 13 }

# Arithmetic expressions
add + me
subtract - me
multiply * me
divide / me

# (x**2) + (y**2)  # TODO exponentiation?

(~7 ^ 3) << 3
0xff | 235
3 % 2 == 0

-negateMe

# Comparison and equality

less < than
lessThan <= orEqual
greater > than
greaterThan >= orEqual

1 == 2         # false.
"cat" != "dog" # true.

314 == "pi" # false.
123 == "123" # false.

# booleans are not implicitly integers (but all expressions do have a "truth" value)
true == 1 # false


# Logical operators

not true  # false.
not false # true.

true and false # false.
true and true  # true.

false or false # false.
true or false  # true.

# Precendence and grouping
var average = (min + max) / 2


# Blocks

begin
  echo "One statement."
  echo "Two statements."
  "Result value."
end

begin
  if condition then
    break "Early exit"  # can break out of blocks early if you want
  end
  "Fallback value."
end


# Variable declaration and assignment

# Assignments come in two flavors: expression or statement

# Assignment expressions are expressions using the assignment operator
# variables can be freely assigned or reassigned
imAVariable = "here is my value"
iAmNil = nil  # initializer is required

# Assignment statements start with the "var" keyword
# while more restricted, they allows you to destructure tuples
var first, second = "abc", "def"

# assignment versions of all binary operators are supported
# however they require the variable to be defined first before use
inc = 0
inc -= 1  # arithmetic assignment

breakfast = "bagels"
echo breakfast # "bagels".

breakfast = "beignets"
echo breakfast # "beignets".

# assignment expressions are expressions, and so can be chained
b = 0
c = 1
a = b += c = d = 1  # chaining assignment (right associative)

del a  # drop a variable from the current scope

# assigment expressions bind weaker than operator expressions
3 * b += c    # Error, assignment target is not an lvalue
3 * (b += c)  # Ok

# variables in global scope can be read but trying to assign to them will only hide them with a local variable
# to assign to a global the "global" keyword has to be used in an assignment statement
# otherwise variables in enclosing scopes can be accessed to freely

tree = "spruce"
fruit = "alderberry"

begin
  echo tree         # spruce

  tree = "oak"
  global fruit = "mango"

  echo fruit        # mango
  echo tree         # oak
  
  echo global tree  # spruce
end

echo tree  # spruce



# Control Flow
# branching constructs are expressions
# looping constructs are statements - in fact, they are the only non-expression statements in ReLox

if condition then
    echo "yes"
else
    echo "no"
end

if condition1 then
  "first"
elif condition2 then
  "second"
else
  "default"
end

var condExpr = 
  if condition1 then
    "first"
  elif condition2 then
    "second"
  else
    "default"
  end
  
# if-expressions and assigment expressions

var a, var b = (1, 2)

# This is not allowed, otherwise anytime an identifier is encountered
# it would be ambiguous whether you want to lookup the value of a variable
# or use it as an assignment target
if cond then a else b end += 1  # error, found if-expression, expected assignment target on LHS of assignment

# You have to do this
if cond then a += 1 else b += 1 end  # works


# loops support both break and continue statements

var a = 1
while a < 10 do
  if exitcond then 
    break
  end
  if skipcond then 
    continue
  end

  echo a
  a += 1
end

do
  var cond = example()
while cond

# for loops TBD

# C-style for loop
# for var i , i < 10 , i+1 do
# end

#{
  iterator-based for loops
  
  # Option 1. Lua style e.g...

  # iterfunc must accept a (i, invariant) and return (next_i, ...)
  for i, ... in iterfunc, invariant, i0 do
    ...
  end
  
  # then with an iter_ctor() that returns the required 3-tuple you would do:
  
  for i, ... in iter_ctor() do
    ...
  end  

  
  # Option 2. Python style...
  
  # iter is an object with __next() metamethod
  for item in iter do
    ...
  end
}#

# Functions

makeBreakfast(bacon, eggs, toast)
makeBreakfast()

fun echoSum(a, b)
  echo a + b
end

fun returnSum(a, b)
  return a + b
end

# Closures

fun addPair(a, b)
  return a + b
end

fun identity(a)
  return a
end

echo identity(addPair)(1, 2) # echos "3".

fun outerFunction()
  fun localFunction()
    echo "I'm local!"
  end

  localFunction()
end

fun returnFunction()
  var outside = "outside"

  fun inner()
    echo outside
  end

  return inner
end

var fn = returnFunction()
fn()

var anonFn = fun(x) x + 1 end
var a = anonFn(3)


# Commenting this out because its kind of experimental
# # Decorator Syntax

# # The "@" syntax can be used to pass a single argument to a function without needing parens
# @f @g h(x)  # equivalent to f(g(h(x)))

# # This is useful for wrapping functions (and classes, which we'll see later), e.g.

# fun trace(tag)
#   return fun(func)
#     echo "Calling " + tag + "!"  # TODO string interpolation
#   end
# end

# @trace("do_stuff")
# fun do_stuff()
#   # do some stuff here
# end

# # There is a bit of subtlety required to make this work.
# # All function definitions are *expressions*, even named functions.
# # Defining a named function e.g. "fun name() ... end" is equivalent to the
# # assignment expression "(name = fun() ... end)"

# # However, whenver a



# Classes

something.field = 1
something.method()

class Breakfast
  var classvar = 0

  # functions whose first parameter is the "self" symbol
  # are automatically converted into builtin method descripter objects
  fun cook(self) 
    echo "Eggs a-fryin'!"
  end
  
  # even when created using an anonymous function
  var serve = fun(self, who)
    echo "Enjoy your breakfast, " + who + "."
  end
end

# and even when created outside of a class body.
# descripters are passed the owning class (and instance, if relevant) when the __get() metamethod is invoked
Breakfast.cook = fun(self)
  echo "Eggs a-fryin'!"
end


# Store it in variables.
var someVariable = Breakfast

# Pass it to functions.
someFunction(Breakfast)

var breakfast = new Breakfast {}  # object initializer
echo breakfast # "Breakfast instance".

# Instantiation and initialization

# originally initializers used { name: value }, but I want to reserve colons for future type hinting
var breakfast = new Breakfast { meat: "sausage", bread: "sourdough" }
breakfast.drink = "coffee"

del breakfast.bread  # remove an object member

var a = 0
var anonymous = new { some: a = 1, data: 2 }

class Breakfast
  fun serve(self, who)
    echo "Enjoy your " + self.meat + " and " +
        self.bread + ", " + who + "."
  end

  # ...
end

class Breakfast
  # constructor function
  fun new(meat, bread)
    return new Breakfast { meat: meat, bread: bread }
  end

end

var baconAndToast = Breakfast.new("bacon", "toast")
baconAndToast.serve("Dear Reader")
# "Enjoy your bacon and toast, Dear Reader."

# Inheritance

class Brunch: Breakfast
  fun drink()
    echo "How about a Bloody Mary?"
  end
end


# Variadic arguments
fun variadicFun(normalArg, variadic...)
  echo normalArg
  
  ## TODO figure out how for loops will work then redo this example
  var i = 0
  while i < variadic.len do
    echo variadic[i]
    i += 1
  end
end

variadicFun("red", "blue", "green")  # prints "red" then "blue" then "green"

var mylist = list.new("red", "green", "blue")  # important use case: constructor functions for collection types

# Argument unpacking

var things = ("second", "third")
variadicFun("first", ...things)  # prints "first" then "second"
variadicFun(...things)  # prints "second" then "third"

# Named Arguments TBD
#{
fun example(positionalArg, :namedArg) 
  if namedArg then
    echo positionalArg
  end
end

example("otter", namedArg: true)

# arguments to function calls must happen in this order
anotherFunc("positional", ...unpackArgs, namedArg: "named")
}#


# Metamethods

class Example
  fun __setindex(self, index)
      echo index
  end
  
  fun __call(self, args...)
      echo args
  end
  
  var __eq = fun(self, other) true end
end

var ex = Example { [0]: "first", [1]: "second" }
ex[2] = "third" 

# List of allowed metamethods:
#
# __add, __mul, __sub, __div, __neg, etc...
# __le, __lt, __eq only, no methamethods for others...
# __getindex, __setindex, __delindex
# __bool, __tostring
# __exit  - for context managers
# __call

# class/instance names with double underscores are reserved for metamethods
class Example
  var __notallowed = true  # error
  
  fun __alsonotallowed(self)
    echo "bad"
  end
end

Example.__fail = -3  # this will result in an error


# Multiple inheritance

class A
  fun method(self)
    echo "A.method() called"
  end
end

class B
  fun method(self)
    echo "B.method() called"
  end
end

class C: A, B end

class D: C, B end

var d = D {}
d.method()  # prints "A.method() called"
# see also: C3 Linearization


